<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>README (obuilder.README)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> – <a href="index.html">obuilder</a> &#x00BB; README</nav><header class="odoc-preamble"><h1 id="obuilder"><a href="#obuilder" class="anchor"></a>OBuilder</h1><p>OBuilder takes a build script (similar to a Dockerfile) and performs the steps in it in a sandboxed environment.</p><p>After each step, OBuilder uses the snapshot feature of the filesystem (ZFS or Btrfs) to store the state of the build. There is also an Rsync backend that copies the build state. On Linux, it uses <code>runc</code> to sandbox the build steps, but any system that can run a command safely in a chroot could be used. Repeating a build will reuse the cached results where possible.</p><p>OBuilder can also use Docker as a backend (fully replacing of <code>runc</code> and the snapshotting filesystem) on any system supported by Docker (Linux, Windows, …).</p><p>OBuilder stores the log output of each build step. This is useful for CI, where you may still want to see the output even if the result was cached from some other build.</p><p>At present, the initial base image is fetched from Docker Hub using <code>docker pull</code> on Linux and then snapshotted into the store. Other systems use a conceptually similar process with the implementation in each platform section.</p></header><nav class="odoc-toc"><ul><li><a href="#usage">Usage</a></li><li><a href="#notes">Notes</a></li><li><a href="#the-build-specification-language">The build specification language</a><ul><li><a href="#multi-stage-builds">Multi-stage builds</a></li><li><a href="#workdir">workdir</a></li><li><a href="#shell">shell</a></li><li><a href="#run">run</a></li><li><a href="#copy">copy</a></li><li><a href="#user">user</a></li><li><a href="#env">env</a></li></ul></li><li><a href="#convert-to-dockerfile-format">Convert to Dockerfile format</a></li><li><a href="#other-platforms">Other Platforms</a></li></ul></nav><div class="odoc-content"><h2 id="usage"><a href="#usage" class="anchor"></a>Usage</h2><p>OBuilder is designed to be used as a component of a build scheduler such as <code>OCluster</code>. However, there is also a command-line interface for testing.</p><p>To check that the system is working correctly, you can run a healthcheck. This checks that Docker is running and then does a simple test build \(pulling the <code>busybox</code> image if not already present\):</p><pre class="language-ocaml"><code>$ obuilder healthcheck --store=zfs:tank
Healthcheck passed</code></pre><p>To build <code>example.spec</code> \(which builds OBuilder itself\) using the ZFS pool <code>tank</code> to cache the build results:</p><pre class="language-ocaml"><code>$ obuilder build -f example.spec . --store=zfs:tank</code></pre><p>To use Btrfs directory <code>/mnt/btrfs</code> for the build cache, use <code>--store=btrfs:/mnt/btrfs</code> or specify a directory for Rsync to use <code>--store=rsync:/rsync</code>.</p><h2 id="notes"><a href="#notes" class="anchor"></a>Notes</h2><p>Some operations \(such as deleting btrfs snapshots\) require root access. OBuilder currently uses <code>sudo</code> as necessary for such operations.</p><p>You should only run one instance of the command-line client at a time with a given store. OBuilder does support concurrent builds, but they must be performed using a single builder object:</p><ul><li>If you try to perform an operation that is already being performed by another build, it will just attach to the existing build.</li><li>The new client will get the logs so far, and then stream new log data as it arrives.</li><li>If a client cancels, it just stops following the log. The operation itself is cancelled if all its clients cancel.</li></ul><p>OBuilder calculates a digest of the input files to decide whether a <code>copy</code> step needs to be repeated. However, if it decides to copy the file to the build sandbox, it does not check the digest again. Also, it only checks that it is not following symlinks during the initial scan. Therefore, you must not modify the input files while a build is in progress.</p><p>Failed build steps are not cached.</p><p>Files and directories in the store may have owners and groups that only make sense in the context of some container. The store should therefore be configured so that other processes on the host \(which might have the same IDs by coincidence\) cannot reach them, e.g. by <code>chmod go-rwx /path/to/store</code>.</p><p>Sync operations can be very slow, especially on btrfs. They're also unnecessary, since if the computer crashes then we'll just discard the whole build and start again. If you have runc version <code>v1.0.0-rc92</code> or later, you can pass the <code>--fast-sync</code> option, which installs a seccomp filter that skips all sync syscalls. However, if you attempt to use this with an earlier version of runc then sync operations will instead fail with <code>EPERM</code>.</p><h2 id="the-build-specification-language"><a href="#the-build-specification-language" class="anchor"></a>The build specification language</h2><p>The spec files are loosely based on the Dockerfile format. The main difference is that the format uses S-expressions rather than a custom format, which should make it easier to generate and consume it automatically.</p><p>When performing a build, the user gives OBuilder a specification file \(as described below\), and a source directory, containing files which may be copied into the image using <code>copy</code>.</p><pre class="language-ocaml"><code>((from BASE) OP…)</code></pre><p>Example:</p><pre class="language-ocaml"><code>((from busybox@sha256:d366a4665ab44f0648d7a00ae3fae139d55e32f9712c67accd604bb55df9d05a)
 (shell /bin/sh -c)
 (run (shell &quot;echo hello world&quot;)))</code></pre><p><code>BASE</code> identifies a Docker image, which will be fetched using <code>docker pull</code> and imported into the OBuilder cache. OBuilder will not check for updates, so <code>BASE</code> should include a digest identifying the exact image, as shown above.</p><p>The operations are performed in order. Each operation gets a build context and a filesystem snapshot, and may produce a new context and a new snapshot. The initial filesystem snapshot is <code>BASE</code>. <code>run</code> and <code>copy</code> operations create new snapshots.</p><p>The initial context is supplied by the user \(see <a href="https://github.com/ocurrent/obuilder/blob/master/lib/build.mli">build.mli</a> for details\). By default:</p><ul><li>The environment is taken from the Docker configuration of <code>BASE</code>.</li><li>The user is <code>(uid 0) (gid 0)</code> on Linux, <code>(name ContainerAdministrator)</code> on Windows.</li><li>The workdir is <code>/</code>, <code>C:/</code> on Windows.</li><li>The shell is <code>bash -c</code>, <code>C:\Windows\System32\cmd.exe /S /C</code> on Windows.</li></ul><h3 id="multi-stage-builds"><a href="#multi-stage-builds" class="anchor"></a>Multi-stage builds</h3><p>You can define nested builds and use the output from them in <code>copy</code> operations. For example:</p><pre class="language-ocaml"><code>((build dev
 ((from ocaml/opam:alpine-3.18-ocaml-5.0)
  (user (uid 1000) (gid 1000))
  (workdir /home/opam)
  (run (shell &quot;echo 'print_endline {|Hello, world!|}' &gt; main.ml&quot;))
  (run (shell &quot;opam exec -- ocamlopt -ccopt -static -o hello main.ml&quot;))))
 (from alpine:3.18)
 (shell /bin/sh -c)
 (copy (from (build dev))
  (src /home/opam/hello)
  (dst /usr/local/bin/hello))
 (run (shell &quot;hello&quot;)))</code></pre><p>At the moment, the <code>(build …)</code> items must appear before the <code>(from …)</code> line.</p><h3 id="workdir"><a href="#workdir" class="anchor"></a>workdir</h3><pre class="language-ocaml"><code>(workdir DIR)</code></pre><p>Example:</p><pre class="language-ocaml"><code>(workdir /usr/local)</code></pre><p>This operation sets the current working directory used for the following commands, until the next <code>workdir</code> operation. If the path given is relative, it is combined with the previous setting. <b>WARNING</b> Workdir implementation is idiosyncratic on macOS, use with care.</p><h3 id="shell"><a href="#shell" class="anchor"></a>shell</h3><pre class="language-ocaml"><code>(shell ARG…)</code></pre><p>Example:</p><pre class="language-ocaml"><code>(shell /bin/bash -c)</code></pre><p>This sets the shell used for future <code>(run (shell COMMAND))</code> operations. The command run will be this list of arguments followed by the single argument <code>COMMAND</code>.</p><h3 id="run"><a href="#run" class="anchor"></a>run</h3><pre class="language-ocaml"><code>(run
 (cache CACHE…)?
 (network NETWORK…)?
 (secrets SECRET…)?
 (shell COMMAND))</code></pre><p>Examples:</p><pre class="language-ocaml"><code>(run (shell &quot;echo hello&quot;))

(run
 (cache (opam-archives (target /home/opam/.opam/download-cache)))
 (network host)
 (secrets (password (target /secrets/password)))
 (shell &quot;opam install utop&quot;))</code></pre><p>Runs the single argument <code>COMMAND</code> using the values in the current context \(set by <code>workdir</code> and <code>shell</code>\).</p><p>The <code>(cache CACHE…)</code> field can be used to mount one or more persistent caches for the command. Each <code>CACHE</code> takes the form <code>(NAME (target PATH))</code>, where <code>NAME</code> uniquely identifies the cache to use and <code>PATH</code> is the mount point within the container.</p><p>If the cache <code>NAME</code> does not yet exist then it is first created as an empty directory, owned by the user in the build context. A mutable copy of the cache is created for the command. When the command finishes \(whether successful or not\) this copy becomes the new version of the cache, unless some other command updated the same cache first, in which case this one is discarded.</p><p>The <code>(network NETWORK…)</code> field specifies which network\(s\) the container will be connected to. <code>(network host)</code> is a special value which runs the container in the host's network namespace. Otherwise, a fresh network namespace is created for the container, with interfaces for the given networks \(if any\).</p><p>Currently, no other networks can be used, so the only options are <code>host</code> or an isolated private network.</p><p>The <code>(secrets SECRET…)</code> field can be used to request values for chosen keys, mounted as read-only files in the image. Each <code>SECRET</code> entry is under the form <code>(ID (target PATH))</code>, where <code>ID</code> selects the secret, and <code>PATH</code> is the location of the mounted secret file within the container. The sandbox context API contains a <code>secrets</code> parameter to provide values to the runtime. If a requested secret isn't provided with a value, the runtime fails. Use the <code>--secret ID:PATH</code> option to provide the path of the file containing the secret for <code>ID</code>. When used with Docker, make sure to use the <b>BuildKit</b> syntax, as only BuildKit supports a <code>--secret</code> option. \(See <a href="https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information">https://docs.docker.com/develop/develop-images/build_enhancements/#new-docker-build-secret-information</a>\)</p><h3 id="copy"><a href="#copy" class="anchor"></a>copy</h3><pre class="language-ocaml"><code>(copy
 (from …)?
 (src SRC…)
 (dst DST)
 (exclude EXCL…)?)</code></pre><p>Examples:</p><pre class="language-ocaml"><code>(copy
 (src .)
 (dst build/)
 (exclude .git _build))

(copy
 (src platform.ml.linux)
 (dst platform.ml))</code></pre><p>This copies files, directories and symlinks from the source directory \(provided by the user when building\) into the image. If <code>DST</code> does not start with <code>/</code> then it is relative to the current workdir.</p><p>It has two forms:</p><ul><li>If <code>DST</code> ends with <code>/</code> then it copies each item in <code>SRC</code> to the directory <code>DST</code>.</li><li>Otherwise, it copies the single item <code>SRC</code> as <code>DST</code>.</li></ul><p>Files whose basenames are listed in <code>exclude</code> are ignored. If <code>exclude</code> is not given, the empty list is used. At present, glob patterns or full paths cannot be used here.</p><p>If <code>(from (build NAME))</code> is given then the source directory is the root directory of the named nested build. Otherwise, it is the source directory provided by the user.</p><p>Notes:</p><ul><li>Unlike Docker's <code>COPY</code> operation, OBuilder copies the files using the current user and group IDs, as set with <code>(user …)</code>.</li><li>Both <code>SRC</code> and <code>DST</code> use <code>/</code> as the directory separator on all platforms.</li><li>The copy is currently done by running <code>tar</code> inside the container to receive the files. Therefore, the filesystem must have a working <code>tar</code> binary. On Windows when using the Docker backend, OBuilder provides a <code>tar</code> binary.</li><li>On Windows, copying from a build step image based on <code>Nano Server</code><code>nanoserver</code> isn't supported.</li></ul><h3 id="user"><a href="#user" class="anchor"></a>user</h3><pre class="language-ocaml"><code>(user (uid UID) (gid GID))
(user (name NAME)) ; on Windows and FreeBSD</code></pre><p>Example:</p><pre class="language-ocaml"><code>(user (uid 1000) (gid 1000))</code></pre><p>This updates the build context to set the user and group IDs used for the following <code>copy</code> and <code>run</code> commands. Note that only numeric IDs are supported.</p><h3 id="env"><a href="#env" class="anchor"></a>env</h3><pre class="language-ocaml"><code>(env NAME VALUE)</code></pre><p>Example:</p><pre class="language-ocaml"><code>(env OPTIONS &quot;-O2 -Wall&quot;)</code></pre><p>Updates the build context so that the environment variable <code>NAME</code> has the value <code>VALUE</code> in future <code>run</code> operations.</p><h2 id="convert-to-dockerfile-format"><a href="#convert-to-dockerfile-format" class="anchor"></a>Convert to Dockerfile format</h2><p>You can convert an OBuilder spec to a Dockerfile like this:</p><pre class="language-ocaml"><code>$ obuilder dockerfile -f example.spec &gt; Dockerfile</code></pre><p>The dockerfile should work the same way as the spec file, except for these limitations:</p><ul><li>In <code>(copy (excludes …) …)</code> the excludes part is ignored. You will need to ensure you have a suitable <code>.dockerignore</code> file instead.</li><li>If you want to include caches or to use secrets, use <code>--buildkit</code> to output in the extended BuildKit syntax.</li><li>All <code>(network …)</code> fields are ignored, as Docker does not allow per-step control of networking.</li></ul><h2 id="other-platforms"><a href="#other-platforms" class="anchor"></a>Other Platforms</h2><p>OBuilder abstracts over a fetching mechanism for the Docker base image, the sandboxing for the execution of build steps and the store for the cache. This makes OBuilder extremely portable and there exists FreeBSD, macOS and Windows backends. The FreeBSD backend uses jails and ZFS, the macOS backend re-uses ZFS and user isolation, and the Windows backend currently requires Docker for Windows installed.</p></div></body></html>