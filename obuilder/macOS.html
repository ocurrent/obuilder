<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>macOS (obuilder.macOS)</title><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">obuilder</a> &#x00BB; macOS</nav><header class="odoc-preamble"><h1 id="experimental-macos-support"><a href="#experimental-macos-support" class="anchor"></a>Experimental macOS Support</h1><p>The macOS backend uses the &quot;user&quot; as the unit of abstraction for sandboxing. That is, for each build a new user is created. This user inherits a home-directory from the store which may come from previous builds using the storage backend.</p><p>A macOS base image is really just a home directory and only requires one file to work, an <code>.obuilder_profile.sh</code>. This is sourced every time a command is run and can be useful for setting paths for a given type of build.</p><p>For <code>spec</code>s that only need local, per-user access this is great but for quite a few builds we also need external system dependencies. On macOS a vast majority of users do this using homebrew. Homebrew installs system dependencies into <code>/usr/local</code> using pre-built binaries \(a.k.a bottles\). It can be placed elsewhere but will often then build from source.</p><p>For OBuilder this means our per-user builds will break if they are all fighting over the global homebrew, so instead OBuilder does the following:</p><ul><li>On macOS we require a scoreboard directory in which we record a symlink that associates a users identifier \(<code>uid</code>\) to the same user's current home directory.</li><li>Another tool, <a href="https://github.com/patricoferris/obuilder-fs">obuilderfs</a>, provides a <code>FUSE</code> filesystem that rewrites access to a given directory \(here <code>/usr/local</code>\) to where the symlink points to in the scoreboard directory.</li><li>A set of <a href="https://github.com/patricoferris/macos-infra/tree/main/scripts">scripts</a> allows us to initialise homebrew in a base image and use this in the <code>(from &lt;base-image&gt;)</code> stage of our builds.</li></ul><p>The goal of the experimental macOS backend was to see how far we get without introducing any virtualisation. It is not intended to be used like the runc-Linux backend because it requires a lot more manual setup and care to be taken.</p></header><nav class="odoc-toc"><ul><li><a href="#running-the-macos-backend-with-zfs">Running the macOS backend with ZFS</a></li><li><a href="#running-the-macos-backend-with-rsync">Running the macOS backend with rsync</a></li><li><a href="#docker-images-for-macos">Docker images for macOS</a></li></ul></nav><div class="odoc-content"><h2 id="running-the-macos-backend-with-zfs"><a href="#running-the-macos-backend-with-zfs" class="anchor"></a>Running the macOS backend with ZFS</h2><p>In order to run the macOS backend to build a very simple <code>spec</code> \(one that doesn't require the FUSE filesystem\) you will need to:</p><ul><li>Install <code>openZFSonOSX</code> and it should be <code>2.0</code> or later \(this is when automatic snapshot mounting was added\).</li><li>Create the &quot;base image&quot; as a directory in <code>/Users</code> i.e <code>sudo mkdir /Users/empty</code> and add an empty <code>.obuilder_profile.sh</code> to that directory. Note this is if you are using the <code>User_temp</code> fetcher module as opposed to the <code>Docker</code> one.</li><li>To get a ZFS pool quickly without partitioning your disk you can run <code>mkfile 128m &lt;some-path&gt;</code> and then <code>sudo zpool create tank &lt;some-path&gt;</code>.</li><li>Create a dummy <code>obuilderfs</code> binary that is in your <code>PATH</code>, this can just be an empty shell-script.</li><li>From the root of this project run: <code>sudo dune exec -- obuilder macos . --store=zfs:/Volumes/tank -f example.macos.spec --uid=705 --fallback=/tmp --scoreboard=/tmp</code>. Because we are not running the FUSE filesystem the <code>fallback</code> and <code>scoreboard</code> directories should be somewhere you don't mind being written to but they won't actually be used.</li></ul><h2 id="running-the-macos-backend-with-rsync"><a href="#running-the-macos-backend-with-rsync" class="anchor"></a>Running the macOS backend with rsync</h2><p>This requires much less setup at the cost of it being very slow in comparison to snap-shotting filesystems. All you need to do is create a directory somewhere for the &quot;snapshots&quot; to be written and pass this as <code>--rsync:/path/to/dir</code>. Of course, you will need <code>rsync</code> installed.</p><h2 id="docker-images-for-macos"><a href="#docker-images-for-macos" class="anchor"></a>Docker images for macOS</h2><p>As mentioned elsewhere, OBuilder also abstracts the initial <code>FETCHER</code> whose job it is, is to interpret the <code>(from &lt;base-image&gt;)</code> stage and setup the base image in a given directory. When run on Linux this uses docker and exports the image and untars the filesystem into the directory. The same can be done for macOS! You can create a directory locally and then use the following dockerfile</p><pre class="language-ocaml"><code>FROM scratch
COPY &lt;/path/to/macos/base/dir&gt; /
CMD [ &quot;/bin/bash&quot; ]</code></pre><p>Note the <code>CMD</code> is important for the internal <code>docker create</code> call to not fail.</p><p>FUSE: <a href="https://osxfuse.github.io/">https://osxfuse.github.io/</a> openZFSonOSX: <a href="https://openzfsonosx.org/wiki/Downloads#2.1.0">https://openzfsonosx.org/wiki/Downloads#2.1.0</a></p></div></body></html>